{
  "version": 3,
  "sources": ["../src/sync.tsx", "../src/laravel-tip.tsx", "../src/hooks/useStoragePath.tsx", "../src/hooks/useBinaryPath.tsx", "../src/hooks/useGithubToken.tsx"],
  "sourcesContent": ["import { showToast, Toast } from \"@raycast/api\";\nimport { sync } from \"./laravel-tip\";\n\nexport default async function Search() {\n  await showToast({\n    style: Toast.Style.Animated,\n    title: \"Syncing\",\n    message: \"Starting to sync all tips from LaravelDaily Repo\",\n  });\n\n  const { error } = await sync();\n\n  if (error) {\n    await showToast({\n      style: Toast.Style.Failure,\n      title: \"Error\",\n      message: error.message,\n    });\n\n    return;\n  }\n\n  await showToast({\n    style: Toast.Style.Success,\n    title: \"Synced\",\n    message: \"All tips have been synced\",\n  });\n}\n", "import path from \"path\";\nimport fs from \"fs\";\nimport { useStoragePath } from \"./hooks/useStoragePath\";\nimport { useBinaryPath } from \"./hooks/useBinaryPath\";\nimport { homedir } from \"os\";\nimport { environment } from \"@raycast/api\";\nimport { spawnSync } from \"child_process\";\nimport { useGithubToken } from \"./hooks/useGithubToken\";\n\nexport interface LaravelTip {\n  id: number;\n  title: string;\n  content: string;\n}\n\nexport class ExecutionError extends Error {}\n\nexport interface ExecutionResult<T> {\n  data?: T;\n  error?: ExecutionError;\n}\n\n/**\n * Get a random tip\n *\n * when no tips are found, it will return an empty object\n */\nexport async function random(): Promise<ExecutionResult<LaravelTip>> {\n  const { data, error } = await execute(\"random\", []);\n\n  if (error) {\n    return { error };\n  }\n\n  if (!data || data.length == 0) {\n    return { data: {} as LaravelTip };\n  }\n\n  return { data: data[0] };\n}\n\n/**\n * Search for tips\n *\n * @param searchText\n */\nexport async function search(searchText: string): Promise<ExecutionResult<LaravelTip[]>> {\n  const { data, error } = await execute(\"search\", [searchText]);\n\n  if (error) {\n    return { error };\n  }\n\n  return { data: data || [] };\n}\n\n/**\n * Start syncing all tips from LaravelDaily Repo, all data will be overwritten\n * when you run this command again.\n */\nexport async function sync(): Promise<ExecutionResult<void>> {\n  const { error } = await execute(\"sync\", []);\n\n  if (error) {\n    return { error };\n  }\n\n  return {};\n}\n\n/**\n * Execute a command with the given arguments\n *\n * @param command\n * @param args\n */\nexport async function execute(command: string, args: string[]): Promise<ExecutionResult<LaravelTip[]>> {\n  // If the data synchronization has not yet been performed, try to sync it first\n  // This usually happens when the user has just installed the extension\n  if (command !== \"sync\" && !(await detectDatabaseFileHasExists())) {\n    const { error } = await sync();\n    if (error) {\n      return { error };\n    }\n  }\n\n  const { data: binaryPath } = await formatBinaryPath(useBinaryPath());\n  if (!binaryPath) {\n    return { error: new ExecutionError(\"Could not find laraveltips binary\") };\n  }\n\n  const { data, error } = await spawn(binaryPath, command, args);\n\n  if (error) {\n    return { error };\n  }\n\n  return { data: data ? JSON.parse(data) : [] };\n}\n\n/**\n * Spawn a process with the given binary path, command and arguments\n *\n * @param binaryPath\n * @param command\n * @param args\n */\nasync function spawn(binaryPath: string, command: string, args: string[]): Promise<ExecutionResult<string>> {\n  const storagePath = useStoragePath();\n  const options = [\"-o\", \"json\", \"-q\"];\n\n  if (storagePath) {\n    options.push(\"--path\", formatStoragePath(storagePath));\n  }\n\n  options.push(command, ...args);\n\n  const { status, stdout, stderr } = spawnSync(binaryPath, options, {\n    env: prepareEnvironment(),\n  });\n\n  if (status !== 0) {\n    return { error: new ExecutionError(stderr.toString()) };\n  }\n\n  return { data: stdout.toString() };\n}\n\n/**\n * Prepare environment variables for the laraveltips binary\n *\n * Why we need this? Sometimes we can't fetch any data from GitHub API, because of the rate limit.\n * API rate limit exceeded for your IP address (But here's the good news: Authenticated requests get a higher rate limit.\n * Check out the documentation for more details).\n *\n * @see https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting\n */\nfunction prepareEnvironment(): NodeJS.ProcessEnv | undefined {\n  const token = useGithubToken();\n  if (token) {\n    return { LARAVEL_TIPS_ACCESS_TOKEN: token };\n  }\n\n  return undefined;\n}\n\n/**\n * Detect if the database file exists, if not, we need to sync the data from the remote server\n * when user run the command for the first time.\n */\nasync function detectDatabaseFileHasExists(): Promise<boolean> {\n  const storagePath = formatStoragePath(useStoragePath());\n\n  // keep the SQLite file name in sync with the laravel-tips package\n  // See: https://github.com/godruoyi/laravel-tips/blob/master/src/storage/sqlite.rs#L33\n  const files = [\".db3\", \".laraveltips.db3\"];\n\n  for (const file of files) {\n    try {\n      await fs.promises.access(path.join(storagePath, file), fs.constants.F_OK);\n\n      return true;\n      // eslint-disable-next-line no-empty\n    } catch {}\n  }\n\n  return false;\n}\n\n/**\n * Format storage path, replacing ~ and $HOME with the actual home directory.\n * example:\n *  ~/.laravel -> /Users/username/.laravel\n *  $HOME/.laravel -> /Users/username/.laravel\n *\n *  Note: when the path is empty, we use ~/.laravel as default\n *\n * @param storagePath\n */\nfunction formatStoragePath(storagePath: string): string {\n  if (!storagePath || storagePath.trim() == \"\") {\n    storagePath = \"~/.laravel\";\n  }\n\n  let fullPath = storagePath.replace(/^~($|\\/|\\\\)/, `${homedir()}$1`);\n  fullPath = fullPath.replace(/\\$(\\w+)/g, (_, p1) => process.env[p1] || \"\");\n\n  const p = path.resolve(fullPath);\n  console.log(\"storagePath\", p);\n\n  return p;\n}\n\n/**\n * When no binary path is provided, use the built-in binary, also we try to make sure\n * the binary is executable.\n *\n * @param binaryPath\n */\nasync function formatBinaryPath(binaryPath: string): Promise<ExecutionResult<string>> {\n  // no binary path provided? use built-in binary\n  if (!binaryPath || binaryPath.trim() == \"\") {\n    binaryPath = `${environment.assetsPath}/laraveltips`;\n  }\n\n  await detect(binaryPath);\n\n  return { data: path.resolve(binaryPath) };\n}\n\n/**\n * Detect if the binary is executable, if not, make it executable.\n *\n * @param binary\n */\nasync function detect(binary: string): Promise<void> {\n  try {\n    await fs.promises.access(binary, fs.constants.X_OK);\n  } catch {\n    await fs.promises.chmod(binary, 0o775);\n  }\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\n\nexport function useStoragePath(): string {\n  return getPreferenceValues<{\n    storagePath: string;\n  }>().storagePath;\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\n\nexport function useBinaryPath(): string {\n  return getPreferenceValues<{\n    binaryPath: string;\n  }>().binaryPath;\n}\n", "import { getPreferenceValues } from \"@raycast/api\";\n\nexport function useGithubToken(): string {\n  return getPreferenceValues<{\n    githubToken: string;\n  }>().githubToken;\n}\n"],
  "mappings": "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",
  "names": ["sync_exports", "__export", "Search", "__toCommonJS", "import_api", "import_path", "import_fs", "import_api", "useStoragePath", "import_api", "useBinaryPath", "import_os", "import_api", "import_child_process", "import_api", "useGithubToken", "ExecutionError", "sync", "error", "execute", "command", "args", "detectDatabaseFileHasExists", "binaryPath", "formatBinaryPath", "useBinaryPath", "ExecutionError", "data", "spawn", "storagePath", "useStoragePath", "options", "formatStoragePath", "status", "stdout", "stderr", "prepareEnvironment", "token", "useGithubToken", "files", "file", "fs", "path", "fullPath", "_", "p1", "p", "detect", "binary", "Search", "error", "sync"]
}
